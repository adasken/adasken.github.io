<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Brisbane Parking Assistant</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <link rel="icon" type="image/svg+xml" href="assets/favicon.svg">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #1a1a1a;
            color: #ffffff;
            height: 100vh;
            overflow: hidden;
            min-width: 320px;
        }

        .main-container, body > div, #map, .header, .filters, .info-panel {
            min-width: 320px;
        }

        .header {
            background-color: #2d2d2d;
            padding: 1rem;
            border-bottom: 2px solid #404040;
            position: relative;
            z-index: 1000;
        }

        .header h1 {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
            color: #4CAF50;
        }

        .search-container {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .search-box {
            flex: 1;
            min-width: 250px;
            position: relative;
        }

        .search-input {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid #404040;
            border-radius: 6px;
            background-color: #333333;
            color: #ffffff;
            font-size: 1rem;
        }

        .search-input:focus {
            outline: none;
            border-color: #4CAF50;
        }

        .search-btn {
            padding: 0.75rem 1.5rem;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.3s;
        }

        .search-btn:hover {
            background-color: #45a049;
        }

        .filters {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 0.5rem;
        }

        .filter-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .filter-select {
            padding: 0.5rem;
            border: 1px solid #404040;
            border-radius: 4px;
            background-color: #333333;
            color: #ffffff;
            font-size: 0.9rem;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .status-free { background-color: #4CAF50; }
        .status-paid { background-color: #FF9800; }
        .status-restricted { background-color: #F44336; }

        #map {
            height: calc(var(--vh, 1vh) * 100);
            width: 100%;
            background-color: #1a1a1a;
        }

        .info-panel {
            position: absolute;
            top: 140px;
            right: 10px;
            width: 300px;
            background-color: #2d2d2d;
            border: 2px solid #404040;
            border-radius: 8px;
            padding: 1rem;
            z-index: 1000;
            max-height: calc(100vh - 160px);
            overflow-y: auto;
            display: none;
        }

        .info-panel h3 {
            color: #4CAF50;
            margin-bottom: 0.5rem;
        }

        .info-item {
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .info-label {
            font-weight: bold;
            color: #cccccc;
        }

        .close-btn {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: none;
            border: none;
            color: #ffffff;
            font-size: 1.2rem;
            cursor: pointer;
        }

        /* Custom leaflet popup styles for dark theme */
        .leaflet-popup-content-wrapper {
            background-color: #2d2d2d;
            color: #ffffff;
            border-radius: 6px;
        }

        .leaflet-popup-content {
            color: #ffffff;
        }

        .leaflet-popup-tip {
            background-color: #2d2d2d;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .search-container {
                flex-direction: column;
                align-items: stretch;
            }
            .filters {
                flex-direction: column;
                align-items: stretch;
            }
            .info-panel {
                position: fixed;
                left: 0;
                right: 0;
                bottom: 0;
                top: auto;
                width: 100vw;
                max-width: 100vw;
                margin: 0;
                border-radius: 16px 16px 0 0;
                box-shadow: 0 -2px 12px rgba(0,0,0,0.2);
                padding: 1rem 0.5rem 2.5rem 0.5rem;
                z-index: 2000;
                max-height: 60vh;
                overflow-y: auto;
                display: none;
            }
            .header {
                padding: 0.5rem 0.3rem;
            }
            .header h1 {
                font-size: 1rem;
            }
            .search-input, .filter-select, .search-btn {
                font-size: 0.95rem;
                padding: 0.5rem;
            }
            .status-indicator {
                font-size: 0.9rem;
            }
            #map {
                height: calc(100vh - 220px);
            }
            .info-item {
                font-size: 0.95rem;
            }
            .filter-group label {
                font-size: 0.95rem;
            }
            .filter-group input[type="range"] {
                width: 100%;
            }
            .filter-group span {
                font-size: 0.95rem;
            }
        }
        @media (max-width: 480px) {
            .header h1 {
                font-size: 0.9rem;
            }
            .info-panel {
                padding: 0.5rem 0.2rem 1.5rem 0.2rem;
                max-height: 70vh;
            }
            .search-input, .filter-select, .search-btn {
                font-size: 0.9rem;
                padding: 0.4rem;
            }
            .info-item {
                font-size: 0.9rem;
            }
            .filter-group label {
                font-size: 0.9rem;
            }
            .filter-group span {
                font-size: 0.9rem;
            }
            .status-indicator {
                font-size: 0.85rem;
            }
        }
        @media (max-width: 375px) {
            .main-container {
                padding-left: 12px !important;
                padding-right: 12px !important;
            }
            .filter-select, .filter-group select {
                width: 100%;
                max-width: 100%;
                box-sizing: border-box;
                overflow: hidden;
                text-overflow: ellipsis;
                display: block;
            }
            html, body {
                min-width: 320px;
            }
            .main-container, body > div, #map, .header, .filters, .info-panel {
                min-width: 320px;
            }
            .header h1 {
                font-size: 0.85rem;
            }
            .search-input, .filter-select, .search-btn {
                font-size: 0.85rem;
                padding: 0.35rem;
            }
            .info-item {
                font-size: 0.85rem;
            }
            .filter-group label, .filter-group span {
                font-size: 0.85rem;
            }
            .status-indicator {
                font-size: 0.8rem;
            }
            .info-panel {
                padding: 0.3rem 0.1rem 1rem 0.1rem;
                max-height: 75vh;
            }
        }
        @media (max-width: 320px) {
            .main-container, body > div, #map, .header, .filters, .info-panel {
                min-width: 0;
                width: 100vw;
                max-width: 100vw;
                box-sizing: border-box;
            }
            .main-container {
                padding-left: 12px !important;
                padding-right: 12px !important;
            }
            .filter-select, .filter-group select {
                width: 100%;
                max-width: 100%;
                box-sizing: border-box;
                overflow: hidden;
                text-overflow: ellipsis;
                display: block;
            }
            .search-input, .filter-select, .search-btn,
            button, input[type="button"], input[type="submit"] {
                width: 100%;
                max-width: 100%;
                box-sizing: border-box;
                margin-bottom: 0.3rem;
                word-break: break-word;
            }
            .search-btn,
            button, input[type="button"], input[type="submit"] {
                width: auto;
                min-width: 80px;
                max-width: 100%;
                display: block;
                margin-left: auto;
                margin-right: auto;
            }
            .header h1 {
                font-size: 0.75rem;
                word-break: break-word;
            }
            .filter-group label, .filter-group span, .info-item {
                font-size: 0.75rem;
                word-break: break-word;
            }
            .filter-group {
                flex-direction: column;
                align-items: flex-start;
            }
            .info-panel {
                padding: 0.2rem 0.05rem 0.5rem 0.05rem;
                max-height: 60vh;
            }
            .status-indicator {
                font-size: 0.7rem;
            }
            .slider-label {
                white-space: normal;
                font-size: 0.7rem;
            }
        }
        :root {
            --vh: 1vh;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>🅿 Brisbane Parking Assistant</h1>
        <div class="search-container">
            <div class="search-box">
                <input type="text" id="searchInput" class="search-input" placeholder="Search for a location in Brisbane...">
            </div>
            <button id="searchBtn" class="search-btn">Search</button>
        </div>
        <div class="filters">
            <div class="filter-group">
                <label class="info-label">Type:</label>
                <select id="typeFilter" class="filter-select">
                    <option value="">All</option>
                    <option value="free">Free parking</option>
                    <option value="paid">Paid parking</option>
                </select>
            </div>
            <div class="filter-group">
                <label class="info-label" id="maxStaySliderLabel">Max Free Stay:</label>
                <input type="range" id="maxStaySlider" class="filter-select" min="30" max="180" step="30" value="30">
                <span id="maxStayValue">30 mins</span>
            </div>
            <div class="filter-group">
                <label class="info-label">Time:</label>
                <input type="datetime-local" id="timeSelector" class="filter-select" value="2025-06-22T23:00">
                <button id="nowBtn" class="filter-select" style="padding: 0.5rem 1rem; margin-left: 0.5rem;">Now</button>
            </div>
            <div class="status-indicator">
                <span class="status-dot status-free"></span><span>Free</span>
                <span class="status-dot status-paid"></span><span>Paid</span>
                <span class="status-dot status-restricted"></span><span>Restricted</span>
            </div>
        </div>
    </div>

    <div id="map"></div>
    
    <div id="infoPanel" class="info-panel">
        <button class="close-btn" onclick="closeInfoPanel()">&times;</button>
        <div id="infoPanelContent"></div>
    </div>

    <script>
        // Load parking data from CSV (now with *_PARKING columns)
        let parkingData = [];
        fetch('data/brisbane-parking-meters_with_inferred_times.csv')
            .then(response => response.text())
            .then(csvText => {
                // Parse CSV properly handling quoted fields
                function parseCSV(text) {
                    const lines = text.split('\n').filter(line => line.trim() !== '');
                    const headers = lines[0].split(',').map(header => header.trim());
                    const result = [];
                    for (let i = 1; i < lines.length; i++) {
                        const line = lines[i];
                        const values = [];
                        let currentValue = '';
                        let inQuotes = false;
                        for (let j = 0; j < line.length; j++) {
                            const char = line[j];
                            if (char === '"') {
                                inQuotes = !inQuotes;
                            } else if (char === ',' && !inQuotes) {
                                values.push(currentValue.trim());
                                currentValue = '';
                            } else {
                                currentValue += char;
                            }
                        }
                        values.push(currentValue.trim());
                        const spot = {};
                        headers.forEach((header, index) => {
                            let value = values[index] || '';
                            spot[header] = value;
                        });
                        result.push(spot);
                    }
                    return result;
                }
                parkingData = parseCSV(csvText);
                updateMaxStaySlider();
                addParkingSpots();
            })
            .catch(error => {
                console.error('Error loading parking data:', error);
                alert('Error loading parking data. Please try refreshing the page.');
            });

        // Initialize map centered on Brisbane CBD
        const map = L.map('map', {
            preferCanvas: true
        }).setView([-27.4698, 153.0251], 13);

        // Add dark tile layer
        L.tileLayer('https://tiles.stadiamaps.com/tiles/alidade_smooth_dark/{z}/{x}/{y}{r}.png', {
            attribution: '&copy; <a href="https://stadiamaps.com/">Stadia Maps</a>, &copy; <a href="https://openmaptiles.org/">OpenMapTiles</a> &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors',
            maxZoom: 19
        }).addTo(map);

        let markers = [];
        let currentInfoMarker = null;

        function determineSpotType(spot) {
            if (spot.TAR_RATE_WEEKDAY === "" || spot.TAR_RATE_WEEKDAY === "0" || !spot.TAR_RATE_WEEKDAY) {
                return 'free';
            } else if (spot.RESTRICTIONS && spot.RESTRICTIONS.includes('LOADING ZONE')) {
                return 'restricted';
            } else {
                return 'paid';
            }
        }

        function getMarkerColor(spotType) {
            switch (spotType) {
                case 'free': return '#4CAF50';
                case 'paid': return '#FF9800';
                case 'restricted': return '#F44336';
                default: return '#9E9E9E';
            }
        }

        function createCustomIcon(color, size = 20, isMotorcycle = false) {
            return L.divIcon({
                className: 'custom-div-icon',
                html: isMotorcycle ? 
                    `<div style="
                        background-color: ${color};
                        width: ${size}px;
                        height: ${size}px;
                        border-radius: 50%;
                        border: 3px solid #ffffff;
                        box-shadow: 0 2px 6px rgba(0,0,0,0.3);
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: ${size * 0.6}px;
                    ">🏍️</div>` :
                    `<div style="
                    background-color: ${color};
                    width: ${size}px;
                    height: ${size}px;
                    border-radius: 50%;
                    border: 3px solid #ffffff;
                    box-shadow: 0 2px 6px rgba(0,0,0,0.3);
                "></div>`,
                iconSize: [size, size],
                iconAnchor: [size/2, size/2]
            });
        }

        function formatOperationalTime(time) {
            if (!time) return 'Not specified';
            return time.replace(/MON-FRI/g, 'Mon-Fri')
                      .replace(/SAT-SUN/g, 'Sat-Sun')
                      .replace(/7 DAYS/g, '7 Days');
        }

        function isCurrentlyFree(spot) {
            const now = new Date();
            const currentHour = now.getHours();
            const currentDay = now.getDay(); // 0 = Sunday, 1 = Monday, etc.
            
            // Simple logic - can be enhanced based on operational times
            if (spot.OPERATIONAL_TIME.includes('7PM-10PM') && 
               (currentHour >= 19 || currentHour < 7)) {
                return true;
            }
            
            if (spot.OPERATIONAL_DAY === '5 DAYS' && (currentDay === 0 || currentDay === 6)) {
                return true;
            }
            
            return determineSpotType(spot) === 'free';
        }

        function parseRestrictions(restrictions) {
            if (!restrictions) return [];
            const timeRanges = [];
            // Split by & to handle multiple restriction groups
            const parts = restrictions.split('&').map(part => part.trim());

            parts.forEach(part => {
                // Find all restriction types (words or abbreviations before the time)
                const typeMatches = part.match(/([A-Z\/ ]+?)(?=\d|$)/gi) || [];
                // Find all time ranges in the part
                const timeMatches = part.match(/(\d{1,2}(?::\d{2})?(?:AM|PM))-(\d{1,2}(?::\d{2})?(?:AM|PM))/gi);
                // Find day patterns
                const dayMatch = part.match(/(?:MON-FRI|SAT-SUN|MON|TUE|WED|THU|FRI|SAT|SUN)/i);
                const days = dayMatch ? dayMatch[0] : undefined;

                if (timeMatches && days) {
                    typeMatches.forEach(type => {
                        timeMatches.forEach(timeRange => {
                            const parsedRange = parseTimeRange(`${timeRange} ${days}`);
                            if (parsedRange.length > 0) {
                                parsedRange[0].restrictionType = type.trim();
                                timeRanges.push(parsedRange[0]);
                            }
                        });
                    });
                } else if (typeMatches.length) {
                    // If no time, treat as all day
                    typeMatches.forEach(type => {
                        timeRanges.push({
                            start: 0,
                            end: 24 * 60 - 1,
                            days: [0,1,2,3,4,5,6],
                            restrictionType: type.trim()
                        });
                    });
                }
            });
            return timeRanges;
        }

        function parseTimeRange(timeStr) {
            if (!timeStr) return [];
            
            const ranges = [];
            // Split by comma and handle parentheses
            const parts = timeStr.split(',').map(part => {
                // Handle both formats: "7AM-7PM (MON-FRI)" and "7AM-7PM(MON-FRI)"
                const match = part.trim().match(/(.*?)(?:\s*\((.*?)\)|\s+(MON-FRI|SAT-SUN|7 DAYS|6 DAYS|5 DAYS|SAT|SUN))$/);
                return {
                    timeRange: match ? match[1].trim() : part.trim(),
                    days: match ? match[2] || match[3] : '7 DAYS'
                };
            });
            
            parts.forEach(({timeRange, days}) => {
                if (!timeRange) return;
                
                const [start, end] = timeRange.split('-').map(t => {
                    const [hours, period] = t.trim().split(/(?=[AP]M)/);
                    let [h, m] = hours.split(':').map(Number);
                    if (period === 'PM' && h !== 12) h += 12;
                    if (period === 'AM' && h === 12) h = 0;
                    return h * 60 + (m || 0);
                });
                
                const dayMap = {
                    'MON-FRI': [1, 2, 3, 4, 5],
                    'SAT-SUN': [6, 0],
                    '7 DAYS': [0, 1, 2, 3, 4, 5, 6],
                    '6 DAYS': [1, 2, 3, 4, 5, 6],
                    '5 DAYS': [1, 2, 3, 4, 5],
                    'MON': [1], 'TUE': [2], 'WED': [3], 'THU': [4], 'FRI': [5], 'SAT': [6], 'SUN': [0]
                };
                
                const dayList = dayMap[days.toUpperCase()] || [];
                
                ranges.push({ start, end, days: dayList });
            });
            
            return ranges;
        }

        function parseOperationalDay(dayStr) {
            if (!dayStr) return [];
            
            const dayMap = {
                'MON-FRI': [1, 2, 3, 4, 5],
                'SAT-SUN': [6, 0],
                '7 DAYS': [0, 1, 2, 3, 4, 5, 6],
                '6 DAYS': [1, 2, 3, 4, 5, 6],
                '5 DAYS': [1, 2, 3, 4, 5],
                '7': [0, 1, 2, 3, 4, 5, 6]
            };
            
            return dayMap[dayStr.toUpperCase()] || [];
        }

        function isTimeInRange(time, ranges) {
            const minutes = time.getHours() * 60 + time.getMinutes();
            const day = time.getDay();
            
            // If no ranges, consider it always in range
            if (ranges.length === 0) {
                return true;
            }
            
            return ranges.some(range => {
                // For restrictions, we want to be inclusive of the start time but exclusive of the end time
                // This means if a restriction is 4PM-7PM, it's restricted from 4:00 PM to 6:59 PM
                const inTimeRange = minutes >= range.start && minutes < range.end;
                const inDayRange = range.days.includes(day);
                return inTimeRange && inDayRange;
            });
        }

        function getParkingRate(spot, time) {
            const day = time.getDay();
            const hour = time.getHours();
            const isWeekend = day === 0 || day === 6; // 0 = Sunday, 6 = Saturday
            const isWeekday = day >= 1 && day <= 5;
            
            // Check if it's within weekday hours (7am-7pm)
            const isWeekdayHours = hour >= 7 && hour < 19;
            
            if (isWeekend || !isWeekdayHours) {
                // For weekends or after hours, use TAR_RATE_AH_WE
                return spot.TAR_RATE_AH_WE || '0';
            } else if (isWeekday && isWeekdayHours) {
                // For weekday hours, use TAR_RATE_WEEKDAY
                return spot.TAR_RATE_WEEKDAY || '0';
            }
            
            return '0';
        }

        function checkParkingAvailability(spot) {
            const selectedTime = new Date(document.getElementById('timeSelector').value);
            const day = selectedTime.getDay();
            const minutes = selectedTime.getHours() * 60 + selectedTime.getMinutes();
            
            // Step 1: Check if the spot is restricted at this time
            const restrictions = parseRestrictions(spot.RESTRICTIONS);
            const isRestricted = restrictions.length > 0 && isTimeInRange(selectedTime, restrictions);
            
            // If restricted, check if it's a NO STOPPING restriction
            if (isRestricted) {
                const activeRestriction = restrictions.find(r => 
                    isTimeInRange(selectedTime, [r]) && 
                    r.restrictionType.toUpperCase().includes('NO STOPPING')
                );
                
                if (activeRestriction) {
                    return { available: false, reason: 'No Stopping' };
                }
            }
            
            // Step 2: Check if the spot is operational on this day
            const operationalDays = parseOperationalDay(spot.OPERATIONAL_DAY);
            const isOperationalDay = operationalDays.includes(day);
            
            // Special case: If operational days is MON-FRI or 5 DAYS and it's weekend, it's free
            if ((spot.OPERATIONAL_DAY === 'MON-FRI' || spot.OPERATIONAL_DAY === '5 DAYS') && (day === 0 || day === 6)) {
                return {
                    available: true,
                    paid: false,
                    reason: 'Free (Weekend)',
                    rate: '0'
                };
            }
            
            // Special case: For 6 DAYS spots, if it's not an operational day but there are no restrictions,
            // the spot should be available and free
            if (spot.OPERATIONAL_DAY === '6 DAYS' && !isOperationalDay) {
                return {
                    available: true,
                    paid: false,
                    reason: 'Free (Non-Operational Day)',
                    rate: '0'
                };
            }
            
            // If it's not an operational day and not one of the special cases above, the spot is not available
            if (!isOperationalDay) {
                return { available: false, reason: 'Not Operational' };
            }
            
            // Step 3: Check if we're in operational hours
            const operationalTimes = parseTimeRange(spot.OPERATIONAL_TIME);
            const isOperationalTime = isTimeInRange(selectedTime, operationalTimes);
            
            // Step 4: Determine the rate
            const rate = getParkingRate(spot, selectedTime);
            
            // If we're in operational hours, use the rate
            // If we're outside operational hours, it's free
            return {
                available: true,
                paid: isOperationalTime && rate !== '0',
                reason: isOperationalTime ? (rate !== '0' ? 'Paid' : 'Free') : 'Free',
                rate: isOperationalTime ? rate : '0'
            };
        }

        function isMotorcycleOnly(spot) {
            return spot.RESTRICTIONS && 
                   spot.RESTRICTIONS.toUpperCase().includes('M/C PARKING') && 
                   (!spot.VEH_BAYS || spot.VEH_BAYS === '0');
        }

        // New function to get parking status from *_PARKING columns
        function getParkingStatus(spot, selectedDate) {
            const days = ['SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT'];
            const dayKey = days[selectedDate.getDay()] + '_PARKING';
            let parkingRanges;
            try {
                parkingRanges = JSON.parse(spot[dayKey].replace(/'/g, '"'));
            } catch (e) {
                return { type: 'Unknown', fee: null };
            }
            const minutes = selectedDate.getHours() * 60 + selectedDate.getMinutes();
            for (const range of parkingRanges) {
                const fromParts = range.from.split(':').map(Number);
                const toParts = range.to.split(':').map(Number);
                const fromMinutes = fromParts[0] * 60 + fromParts[1];
                const toMinutes = toParts[0] * 60 + toParts[1];
                if (fromMinutes <= toMinutes) {
                    if (minutes >= fromMinutes && minutes < toMinutes) {
                        return range;
                    }
                } else {
                    if (minutes >= fromMinutes || minutes < toMinutes) {
                        return range;
                    }
                }
            }
            return { type: 'Unknown', fee: null };
        }

        // Restore the getMaxFreeStay function for free parking logic
        function getMaxFreeStay(spot, selectedDate) {
            const days = ['SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT'];
            let dayIdx = selectedDate.getDay();
            let dayKey = days[dayIdx] + '_PARKING';
            let minutesNow = selectedDate.getHours() * 60 + selectedDate.getMinutes();
            let totalFree = 0;
            let foundFree = false;
            let maxLoops = 8; // Prevent infinite loop, max 7 days lookahead

            for (let loop = 0; loop < maxLoops; loop++) {
                let parkingRanges;
                try {
                    parkingRanges = JSON.parse(spot[dayKey].replace(/'/g, '"'));
                } catch (e) {
                    return 'Unknown';
                }
                for (let i = 0; i < parkingRanges.length; i++) {
                    const range = parkingRanges[i];
                    const fromParts = range.from.split(':').map(Number);
                    const toParts = range.to.split(':').map(Number);
                    const fromMinutes = fromParts[0] * 60 + fromParts[1];
                    const toMinutes = toParts[0] * 60 + toParts[1];

                    // Find the current free interval
                    if (
                        range.type === 'Free' &&
                        ((fromMinutes <= toMinutes && minutesNow >= fromMinutes && minutesNow < toMinutes) ||
                         (fromMinutes > toMinutes && (minutesNow >= fromMinutes || minutesNow < toMinutes)))
                    ) {
                        foundFree = true;
                        let minsLeft;
                        if (fromMinutes <= toMinutes) {
                            minsLeft = toMinutes - minutesNow;
                        } else {
                            // Wraps past midnight
                            minsLeft = (24 * 60 - minutesNow) + toMinutes;
                        }
                        totalFree += minsLeft;

                        // If this interval ends at 23:59, check if the next day's first interval is also free and starts at 00:00
                        let nextDayIdx = (dayIdx + 1) % 7;
                        let nextDayKey = days[nextDayIdx] + '_PARKING';
                        if (
                            (toMinutes === 1439) && // 23:59
                            loop < maxLoops - 1
                        ) {
                            let nextDayRanges;
                            try {
                                nextDayRanges = JSON.parse(spot[nextDayKey].replace(/'/g, '"'));
                            } catch (e) {
                                break;
                            }
                            if (nextDayRanges.length > 0) {
                                const nextRange = nextDayRanges[0];
                                if (nextRange.type === 'Free' && nextRange.from === '00:00') {
                                    // Continue summing into next day's free interval
                                    let nextToParts = nextRange.to.split(':').map(Number);
                                    let nextToMinutes = nextToParts[0] * 60 + nextToParts[1];
                                    totalFree += nextToMinutes;
                                    // Prepare for next day
                                    dayIdx = nextDayIdx;
                                    dayKey = nextDayKey;
                                    minutesNow = 0;
                                    // Continue the outer loop
                                    break;
                                }
                            }
                        }
                        // Otherwise, stop
                        loop = maxLoops;
                        break;
                    }
                }
                break; // Only need to check current and possibly next day
            }
            // Show exact duration in hours and minutes
            if (totalFree <= 0) return '0';
            const hours = Math.floor(totalFree / 60);
            const mins = totalFree % 60;
            let result = '';
            if (hours > 0) result += `${hours} Hour${hours === 1 ? '' : 's'}`;
            if (mins > 0) result += (hours > 0 ? ' ' : '') + `${mins} mins`;
            return result.trim();
        }

        // Helper to get max paid stay from current time, similar to getMaxFreeStay
        function getMaxPaidStay(spot, selectedDate) {
            const days = ['SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT'];
            let dayIdx = selectedDate.getDay();
            let dayKey = days[dayIdx] + '_PARKING';
            let minutesNow = selectedDate.getHours() * 60 + selectedDate.getMinutes();
            let totalPaid = 0;
            let foundPaid = false;
            let maxLoops = 2;
            for (let loop = 0; loop < maxLoops; loop++) {
                let parkingRanges;
                try {
                    parkingRanges = JSON.parse(spot[dayKey].replace(/'/g, '"'));
                } catch (e) {
                    return 'Unknown';
                }
                for (let i = 0; i < parkingRanges.length; i++) {
                    const range = parkingRanges[i];
                    const fromParts = range.from.split(':').map(Number);
                    const toParts = range.to.split(':').map(Number);
                    const fromMinutes = fromParts[0] * 60 + fromParts[1];
                    const toMinutes = toParts[0] * 60 + toParts[1];
                    if (
                        range.type === 'Paid' &&
                        ((fromMinutes <= toMinutes && minutesNow >= fromMinutes && minutesNow < toMinutes) ||
                         (fromMinutes > toMinutes && (minutesNow >= fromMinutes || minutesNow < toMinutes)))
                    ) {
                        foundPaid = true;
                        let minsLeft;
                        if (fromMinutes <= toMinutes) {
                            minsLeft = toMinutes - minutesNow;
                        } else {
                            minsLeft = (24 * 60 - minutesNow) + toMinutes;
                        }
                        totalPaid += minsLeft;
                        // If this interval ends at 23:59, check if the next day's first interval is also paid and starts at 00:00
                        let nextDayIdx = (dayIdx + 1) % 7;
                        let nextDayKey = days[nextDayIdx] + '_PARKING';
                        if (
                            (toMinutes === 1439) &&
                            loop < maxLoops - 1
                        ) {
                            let nextDayRanges;
                            try {
                                nextDayRanges = JSON.parse(spot[nextDayKey].replace(/'/g, '"'));
                            } catch (e) {
                                break;
                            }
                            if (nextDayRanges.length > 0) {
                                const nextRange = nextDayRanges[0];
                                if (nextRange.type === 'Paid' && nextRange.from === '00:00') {
                                    let nextToParts = nextRange.to.split(':').map(Number);
                                    let nextToMinutes = nextToParts[0] * 60 + nextToParts[1];
                                    totalPaid += nextToMinutes;
                                    dayIdx = nextDayIdx;
                                    dayKey = nextDayKey;
                                    minutesNow = 0;
                                    break;
                                }
                            }
                        }
                        loop = maxLoops;
                        break;
                    }
                }
                break;
            }
            if (totalPaid <= 0) return '0';
            const hours = Math.floor(totalPaid / 60);
            const mins = totalPaid % 60;
            let result = '';
            if (hours > 0) result += `${hours} Hour${hours === 1 ? '' : 's'}`;
            if (mins > 0) result += (hours > 0 ? ' ' : '') + `${mins} mins`;
            return result.trim();
        }

        // Helper to parse duration string (e.g., '2 Hours 30 mins') to minutes
        function parseDurationToMinutes(duration) {
            if (!duration || duration === 'Unknown' || duration === '0') return 0;
            let mins = 0;
            const hourMatch = duration.match(/(\d+)\s*Hour/);
            if (hourMatch) mins += parseInt(hourMatch[1]) * 60;
            const minMatch = duration.match(/(\d+)\s*min/);
            if (minMatch) mins += parseInt(minMatch[1]);
            return mins;
        }

        // Update Max Stay/Free Stay slider based on type and current selected time
        function updateMaxStaySlider() {
            const selectedTime = new Date(document.getElementById('timeSelector').value);
            const type = document.getElementById('typeFilter').value;
            let maxMins = 0;
            let minMins = 30;
            if (type === 'paid') {
                // For paid parking, use MAX_STAY_HRS
                let uniqueStays = new Set();
            parkingData.forEach(spot => {
                    if (spot.MAX_STAY_HRS && !isNaN(spot.MAX_STAY_HRS)) {
                        let mins = Math.round(parseFloat(spot.MAX_STAY_HRS) * 60);
                        if (mins >= 30) uniqueStays.add(mins);
                    }
                });
                if (uniqueStays.size === 0) uniqueStays.add(30);
                const stays = Array.from(uniqueStays).sort((a, b) => a - b);
                maxMins = stays[stays.length - 1];
                minMins = stays[0];
                const slider = document.getElementById('maxStaySlider');
                slider.max = maxMins;
                slider.min = minMins;
                slider.step = 30;
                if (parseInt(slider.value) > maxMins) slider.value = maxMins;
                if (parseInt(slider.value) < minMins) slider.value = minMins;
                updateMaxStayValueLabel();
                // Update label
                const label = document.getElementById('maxStaySliderLabel');
                label.textContent = 'Max Stay:';
                        return;
            } else {
                // Free parking logic as before
                parkingData.forEach(spot => {
                    const mins = parseDurationToMinutes(getMaxFreeStay(spot, selectedTime));
                    if (mins > maxMins) maxMins = mins;
                });
                if (maxMins < 30) maxMins = 30;
                const slider = document.getElementById('maxStaySlider');
                slider.max = maxMins;
                slider.min = 30;
                slider.step = 30;
                if (parseInt(slider.value) > maxMins) slider.value = maxMins;
                if (parseInt(slider.value) < 30) slider.value = 30;
                updateMaxStayValueLabel();
                // Update label
                const label = document.getElementById('maxStaySliderLabel');
                label.textContent = 'Max Free Stay:';
            }
        }

        function updateMaxStayValueLabel() {
            const slider = document.getElementById('maxStaySlider');
            const value = parseInt(slider.value);
            let label = '';
            if (value < 60) label = `${value} mins`;
            else if (value % 60 === 0) label = `${value / 60} hour${value === 60 ? '' : 's'}`;
            else label = `${Math.floor(value / 60)}.${(value % 60) / 60 * 10 | 0} hours`;
            document.getElementById('maxStayValue').textContent = label.charAt(0).toUpperCase() + label.slice(1);
        }

        function addParkingSpots() {
            // Clear existing markers
            markers.forEach(marker => map.removeLayer(marker));
            markers = [];
            const typeFilter = document.getElementById('typeFilter').value;
            const maxStaySlider = document.getElementById('maxStaySlider');
            const maxStayFilter = maxStaySlider ? maxStaySlider.value : '';
            const selectedTime = new Date(document.getElementById('timeSelector').value);
            parkingData.forEach(spot => {
                const status = getParkingStatus(spot, selectedTime);
                if (typeFilter === 'free' || typeFilter === '') {
                    // Free parking logic
                    if (status.type === 'Free') {
                        const freeMins = parseDurationToMinutes(getMaxFreeStay(spot, selectedTime));
                        if (maxStayFilter && freeMins < parseInt(maxStayFilter)) return;
                    } else if (typeFilter === 'free') {
                        return; // Don't show paid parking if filter is 'free'
                    }
                }
                if (typeFilter === 'paid') {
                    if (status.type === 'Paid') {
                        // For paid parking, filter by MAX_STAY_HRS
                        let stayMins = 0;
                        if (spot.MAX_STAY_HRS && !isNaN(spot.MAX_STAY_HRS)) {
                            stayMins = Math.round(parseFloat(spot.MAX_STAY_HRS) * 60);
                        }
                        if (maxStayFilter && stayMins < parseInt(maxStayFilter)) return;
                    } else {
                        return; // Don't show free parking if filter is 'paid'
                    }
                }
                // Set marker color based on status
                let color = '#9E9E9E';
                if (status.type === 'Free') color = '#4CAF50';
                else if (status.type === 'Paid') color = '#FF9800';
                else if (status.type === 'No parking' || status.type === 'Restricted') color = '#F44336';
                const isMotorcycle = spot.RESTRICTIONS && spot.RESTRICTIONS.toUpperCase().includes('M/C PARKING');
                const marker = L.marker([parseFloat(spot.LATITUDE), parseFloat(spot.LONGITUDE)], {
                    icon: createCustomIcon(color, 20, isMotorcycle)
                }).addTo(map);
                // Popup content
                const popupContent = `
                    <div style="color: #ffffff;">
                        <h3 style="color: ${color}; margin-bottom: 8px;">${spot.STREET}, ${spot.SUBURB}</h3>
                        <p><strong>Meter ID:</strong> ${spot.METER_NO}</p>
                        <p><strong>Vehicle Bays:</strong> ${spot.VEH_BAYS || 0}</p>
                        <p><strong>Motorcycle Bays:</strong> ${spot.MC_BAYS || 0}</p>
                        <p><strong>Free Time Remaining:</strong> ${getMaxFreeStay(spot, selectedTime)}</p>
                        <p><strong>Status:</strong> ${status.type}</p>
                        ${status.type === 'Paid' ? `<p><strong>Rate:</strong> $${status.fee}/hour</p>` : ''}
                        <p><strong>Restrictions:</strong> ${spot.RESTRICTIONS || 'None'}</p>
                        <p><strong>Operational Time:</strong> ${spot.OPERATIONAL_TIME || 'Not specified'}</p>
                        ${isMotorcycle ? '<p style="color: #FF9800;"><strong>🏍️ Motorcycle Only</strong></p>' : ''}
                    </div>
                `;
                marker.bindPopup(popupContent);
                marker.on('click', function() {
                    showInfoPanel(spot, status);
                });
                markers.push(marker);
            });
        }

        function showInfoPanel(spot, status) {
            const panel = document.getElementById('infoPanel');
            const content = document.getElementById('infoPanelContent');
            const selectedTime = new Date(document.getElementById('timeSelector').value);
            // Determine if this spot has a paid interval at the selected time
            let paidStay = '';
            if (spot.MAX_STAY_HRS && !isNaN(spot.MAX_STAY_HRS)) {
                paidStay = `${spot.MAX_STAY_HRS} Hour${parseFloat(spot.MAX_STAY_HRS) === 1 ? '' : 's'}`;
            }
            content.innerHTML = `
                <h3 style="color: #4CAF50;">${spot.STREET}, ${spot.SUBURB}</h3>
                <div class="info-item">
                    <span class="info-label">Meter ID:</span> ${spot.METER_NO}
                </div>
                <div class="info-item">
                    <span class="info-label">Location:</span> ${spot.LOC_DESC || 'Not specified'}
                </div>
                <div class="info-item">
                    <span class="info-label">Vehicle Bays:</span> ${spot.VEH_BAYS || 0}
                </div>
                <div class="info-item">
                    <span class="info-label">Motorcycle Bays:</span> ${spot.MC_BAYS || 0}
                </div>
                <div class="info-item">
                    <span class="info-label">Max Free Stay:</span> ${getMaxFreeStay(spot, selectedTime)}
                </div>
                ${paidStay ? `<div class="info-item"><span class="info-label">Max Paid Stay:</span> ${paidStay}</div>` : ''}
                <div class="info-item">
                    <span class="info-label">Status:</span> ${status.type}
                </div>
                ${status.type === 'Paid' ? `<div class="info-item"><span class="info-label">Rate:</span> $${status.fee}/hour</div>` : ''}
                <div class="info-item">
                    <span class="info-label">Restrictions:</span> ${spot.RESTRICTIONS || 'None'}
                </div>
                <div class="info-item">
                    <span class="info-label">Operational Days:</span> ${spot.OPERATIONAL_DAY || 'Not specified'}
                </div>
                <div class="info-item">
                    <span class="info-label">Operational Time:</span> ${spot.OPERATIONAL_TIME || 'Not specified'}
                </div>
                <div class="info-item">
                    <span class="info-label">Category:</span> ${spot.CATEGORY || 'Standard'}
                </div>
                ${status.type === 'Free' ? '<div class="info-item" style="color: #4CAF50; font-weight: bold;">🎉 FREE PARKING NOW!</div>' : ''}
            `;
            panel.style.display = 'block';
        }

        function closeInfoPanel() {
            document.getElementById('infoPanel').style.display = 'none';
        }

        function searchLocation() {
            const query = document.getElementById('searchInput').value.trim();
            if (!query) return;

            // Simple search in existing data
            const matches = parkingData.filter(spot => 
                spot.STREET.toLowerCase().includes(query.toLowerCase()) ||
                spot.SUBURB.toLowerCase().includes(query.toLowerCase()) ||
                spot.LOC_DESC.toLowerCase().includes(query.toLowerCase())
            );

            if (matches.length > 0) {
                const firstMatch = matches[0];
                map.setView([firstMatch.LATITUDE, firstMatch.LONGITUDE], 16);
                
                // Highlight matching markers
                markers.forEach(marker => {
                    const markerLatLng = marker.getLatLng();
                    const isMatch = matches.some(match => 
                        Math.abs(match.LATITUDE - markerLatLng.lat) < 0.001 &&
                        Math.abs(match.LONGITUDE - markerLatLng.lng) < 0.001
                    );
                    
                    if (isMatch) {
                        marker.openPopup();
                    }
                });
            } else {
                alert('No parking spots found for this location. Try searching for streets like "Queen St" or suburbs like "Brisbane City".');
            }
        }

        // Event listeners
        document.getElementById('searchBtn').addEventListener('click', searchLocation);
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchLocation();
            }
        });

        document.getElementById('typeFilter').addEventListener('change', function() {
            updateMaxStaySlider();
            // Reset slider to min value for new type
            const slider = document.getElementById('maxStaySlider');
            slider.value = slider.min;
            updateMaxStayValueLabel();
        addParkingSpots();
        });
        document.getElementById('maxStaySlider').addEventListener('input', function() {
            updateMaxStayValueLabel();
            addParkingSpots();
        });
        document.getElementById('timeSelector').addEventListener('change', function() {
            updateMaxStaySlider();
            addParkingSpots();
        });
        document.getElementById('nowBtn').addEventListener('click', function() {
            const now = new Date();
            const pad = n => n.toString().padStart(2, '0');
            const formatted = `${now.getFullYear()}-${pad(now.getMonth()+1)}-${pad(now.getDate())}T${pad(now.getHours())}:${pad(now.getMinutes())}`;
            document.getElementById('timeSelector').value = formatted;
            updateMaxStaySlider();
            addParkingSpots();
        });
        // Also update on page load and after data loads
        updateMaxStaySlider();

        function setVh() {
            document.documentElement.style.setProperty('--vh', `${window.innerHeight * 0.01}px`);
        }
        window.addEventListener('resize', setVh);
        window.addEventListener('orientationchange', setVh);
        window.addEventListener('DOMContentLoaded', setVh);
        setVh();
    </script>
</body>
</html>